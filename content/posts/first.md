---
title: "Start: Code, English & Russian | In√≠cio | –ù–∞—á–∞–ª–æ"
date: 2025-12-18
draft: false
tags: ["Introduction", "Beecrowd", "Languages", "Math"]
---

# My Learning Log 
# –ú–æ–π –∂—É—Ä–Ω–∞–ª –æ–±—É—á–µ–Ω–∏—è 

Welcome to my evolution space. Here I combine my three current challenges: **programming, english, and russian.**

–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ –º–æ—ë –ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–æ —Ä–∞–∑–≤–∏—Ç–∏—è. –ó–¥–µ—Å—å —è —Å–æ–≤–º–µ—â–∞—é —Ç—Ä–∏ –º–æ–∏—Ö —Ç–µ–∫—É—â–∏—Ö –≤—ã–∑–æ–≤–∞: **–ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏–µ, –∞–Ω–≥–ª–∏–π—Å–∫–∏–π –∏ —Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫–∏.**

---

### Portugu√™s
Estou criando essa p√°gina para me motivar a treinar codar diariamente, ao mesmo tempo que evoluo minha escrita em idiomas estrangeiros. Mostrarei meu avan√ßo di√°rio explicando problemas do **Beecrowd**. Meu foco principal ser√° em problemas de matem√°tica, pois acho essa √°rea mais interessante e desafiadora.

### üá∫üá∏ English
I am creating this page to motivate myself to code daily while improving my writing skills in foreign languages. I will share my daily progress by explaining problems from **Beecrowd**. My main focus will be on mathematical problems, as I find this area more interesting and challenging.

### üá∑üá∫ –†—É—Å—Å–∫–∏–π
–Ø —Å–æ–∑–¥–∞—é —ç—Ç—É —Å—Ç—Ä–∞–Ω–∏—Ü—É, —á—Ç–æ–±—ã –º–æ—Ç–∏–≤–∏—Ä–æ–≤–∞—Ç—å —Å–µ–±—è –ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞—Ç—å –∫–∞–∂–¥—ã–π –¥–µ–Ω—å –∏ –æ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω–æ —É–ª—É—á—à–∞—Ç—å –Ω–∞–≤—ã–∫–∏ –ø–∏—Å—å–º–∞ –Ω–∞ –∏–Ω–æ—Å—Ç—Ä–∞–Ω–Ω—ã—Ö —è–∑—ã–∫–∞—Ö. –Ø –±—É–¥—É –¥–µ–ª–∏—Ç—å—Å—è —Å–≤–æ–∏–º –µ–∂–µ–¥–Ω–µ–≤–Ω—ã–º –ø—Ä–æ–≥—Ä–µ—Å—Å–æ–º, –æ–±—ä—è—Å–Ω—è—è –∑–∞–¥–∞—á–∏ —Å –ø–ª–∞—Ç—Ñ–æ—Ä–º—ã **Beecrowd**. –í –æ—Å–Ω–æ–≤–Ω–æ–º —è –±—É–¥—É —Å–æ—Å—Ä–µ–¥–æ—Ç–æ—á–µ–Ω –Ω–∞ –º–∞—Ç–µ–º–∞—Ç–∏—á–µ—Å–∫–∏—Ö –∑–∞–¥–∞—á–∞—Ö, —Ç–∞–∫ –∫–∞–∫ —Å—á–∏—Ç–∞—é —ç—Ç—É –æ–±–ª–∞—Å—Ç—å –Ω–∞–∏–±–æ–ª–µ–µ –∏–Ω—Ç–µ—Ä–µ—Å–Ω–æ–π –∏ —É–≤–ª–µ–∫–∞—Ç–µ–ª—å–Ω–æ–π.

---

## Challenge: Beecrowd 1346 - Child's Play
[Link](https://judge.beecrowd.com/pt/problems/view/1346)

### English
In this problem, the goal is to balance two sets of tiles (similar to dominoes) so that the sum of the upper side equals the sum of the lower side. The mathematical core of the solution lies in calculating the **difference** between the two values on each tile. 

### –†—É—Å—Å–∫–∏–π
–í —ç—Ç–æ–π –∑–∞–¥–∞—á–µ —Ü–µ–ª—å —Å–æ—Å—Ç–æ–∏—Ç –≤ —Ç–æ–º, —á—Ç–æ–±—ã —Å–±–∞–ª–∞–Ω—Å–∏—Ä–æ–≤–∞—Ç—å –¥–≤–∞ –Ω–∞–±–æ—Ä–∞ –ø–ª–∏—Ç–æ–∫ (–ø–æ—Ö–æ–∂–∏—Ö –Ω–∞ –¥–æ–º–∏–Ω–æ) —Ç–∞–∫, —á—Ç–æ–±—ã —Å—É–º–º–∞ –≤–µ—Ä—Ö–Ω–µ–π —Å—Ç–æ—Ä–æ–Ω—ã –±—ã–ª–∞ —Ä–∞–≤–Ω–∞ —Å—É–º–º–µ –Ω–∏–∂–Ω–µ–π —Å—Ç–æ—Ä–æ–Ω—ã. –ú–∞—Ç–µ–º–∞—Ç–∏—á–µ—Å–∫–∞—è —Å—É—Ç—å —Ä–µ—à–µ–Ω–∏—è –∑–∞–∫–ª—é—á–∞–µ—Ç—Å—è –≤ –≤—ã—á–∏—Å–ª–µ–Ω–∏–∏ **—Ä–∞–∑–Ω–æ—Å—Ç–∏** –º–µ–∂–¥—É –¥–≤—É–º—è –∑–Ω–∞—á–µ–Ω–∏—è–º–∏ –Ω–∞ –∫–∞–∂–¥–æ–π –ø–ª–∏—Ç–∫–µ.

---

### Implementation (C++)

**Why C++?**
Most of these mathematical problems will be solved using C++. I prefer this language because of the precision and control it offers in complex calculations, as well as its efficiency in handling large volumes of data. 

**–ü–æ—á–µ–º—É C++?**
–ë–æ–ª—å—à–∏–Ω—Å—Ç–≤–æ —ç—Ç–∏—Ö –º–∞—Ç–µ–º–∞—Ç–∏—á–µ—Å–∫–∏—Ö –∑–∞–¥–∞—á –±—É–¥—É—Ç —Ä–µ—à–µ–Ω—ã –Ω–∞ C++. –Ø –ø—Ä–µ–¥–ø–æ—á–∏—Ç–∞—é —ç—Ç–æ—Ç —è–∑—ã–∫ –∏–∑-–∑–∞ —Ç–æ—á–Ω–æ—Å—Ç–∏ –∏ –∫–æ–Ω—Ç—Ä–æ–ª—è, –∫–æ—Ç–æ—Ä—ã–µ –æ–Ω –ø—Ä–µ–¥–ª–∞–≥–∞–µ—Ç –≤ —Å–ª–æ–∂–Ω—ã—Ö –≤—ã—á–∏—Å–ª–µ–Ω–∏—è—Ö, –∞ —Ç–∞–∫–∂–µ –∏–∑-–∑–∞ –µ–≥–æ —ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –±–æ–ª—å—à–∏—Ö –æ–±—ä–µ–º–æ–≤ –¥–∞–Ω–Ω—ã—Ö.

```cpp
#include <iostream>
#include <vector>
#include <numeric>
#include <algorithm>
#include <bitset>

using namespace std;

const int SOMA_MAXIMA = 400005;

struct Peca {
    int x, y, id;
    int diferenca; // v - u: the potential shift between top and bottom sums
    int soma;      // u + v: total value contributed by this tile
};

bool compararPecas(const Peca& a, const Peca& b) {
    if (a.soma != b.soma) return a.soma < b.soma;
    if (a.x != b.x) return a.x < b.x;
    return a.y < b.y;
}

void resolver() {
    int N;
    while (cin >> N && N != 0) {
        vector<Peca> pecas(N);
        int soma_total_diferencas = 0;
        int soma_total_valores = 0;

        for (int i = 0; i < N; ++i) {
            int u, v;
            cin >> u >> v;
            if (u > v) swap(u, v); 
            pecas[i] = {u, v, i, v - u, u + v};
            soma_total_diferencas += (v - u);
            soma_total_valores += (u + v);
        }

        bool tudo_possivel = false;
        if (soma_total_diferencas % 2 == 0) {
            bitset<SOMA_MAXIMA> dp;
            dp[0] = 1;
            int alvo = soma_total_diferencas / 2; 
            
            for (const auto& p : pecas) {
                dp |= (dp << p.diferenca); 
            }
            
            if (dp[alvo]) {
                cout << soma_total_valores / 2 << " discard none" << endl;
                tudo_possivel = true;
            }
        }

        if (tudo_possivel) continue;

        sort(pecas.begin(), pecas.end(), compararPecas);
        vector<bitset<SOMA_MAXIMA>> prefixo(N + 1);
        prefixo[0][0] = 1;
        for (int i = 0; i < N; ++i) {
            prefixo[i+1] = prefixo[i] | (prefixo[i] << pecas[i].diferenca);
        }

        vector<bitset<SOMA_MAXIMA>> sufixo_rev(N + 1);
        sufixo_rev[N][SOMA_MAXIMA - 1] = 1; 

        for (int i = N - 1; i >= 0; --i) {
            sufixo_rev[i] = sufixo_rev[i+1] | (sufixo_rev[i+1] >> pecas[i].diferenca);
        }

        bool encontrado = false;
        for (int k = 0; k < N; ++k) {
            int soma_diferenca_atual = soma_total_diferencas - pecas[k].diferenca;
            if (soma_diferenca_atual % 2 != 0) continue;
            
            int alvo = soma_diferenca_atual / 2;
            int deslocamento = SOMA_MAXIMA - 1 - alvo;

            if ((prefixo[k] & (sufixo_rev[k+1] >> deslocamento)).any()) {
                cout << (soma_total_valores - pecas[k].soma) / 2 << " discard " << pecas[k].x << " " << pecas[k].y << endl;
                encontrado = true;
                break;
            }
        }
        if (!encontrado) cout << "impossible" << endl;
    }
}

int main() {
    ios_base::sync_with_stdio(false); 
    cin.tie(NULL);
    resolver();
    return 0;
}
```


---
that's it for today! ;)
I'll be back tomorrow with another problem.

–ù–∞ —Å–µ–≥–æ–¥–Ω—è —ç—Ç–æ –≤—Å—ë! ;) 
–ó–∞–≤—Ç—Ä–∞ —è –≤–µ—Ä–Ω—É—Å—å —Å –Ω–æ–≤–æ–π –∑–∞–¥–∞—á–µ–π.